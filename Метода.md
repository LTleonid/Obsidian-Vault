Тема: Структуры, Директории Препроцессора


# Директивы Препроцессора
---
## Директивы Препроцессора  -  Это команды, которые выполняются до запуска основного кода. Препроцессор добавляет в компилятор нужные библиотеки, макросы или же помогает определить что-либо в компиляторе.\
![86cb3fa2a7b0a0c425bc10c74ce3d5dd](https://github.com/user-attachments/assets/c4072e55-f188-408d-b0bb-7ebb7f26b478)



# Директивы

## ```#include ``` :

### Директив include(с англ. -  Включать/Содержать) - Позволяет добавить к коду какую либо библиотеку для дальнейшей работы с ней
### например ``` #include <iostream> ```
Включает в код стандартную библиотеку iostream в код, 

### Учтите - В треугольных кавычках <> записываются стандартные библиотеки которые установлены по умолчанию | В Двустрочные кавычки " ", Включаются твои библиотеки(Обязательно указывается файл с расширением .h - Header )
```cpp
#include <map> //Включает СТАНДРАТНУЮ библиотеку map
#include "YourBiblo.h" //Включает ВАШУ библиотеку YourBiblio.h
```

### Как определить Заголовочный файл(Библиотеку):
Кроме стандартных заголовочных файлов мы можем подключать и свои файлы. Например, в той же папке, где находиться главный файл программы, определим еще один файл, который назовем numbers.h.

Определим в нем следующий код:

```int number = 5;```
И в коде основного файла пишем:
```cpp
#include <iostream>
#include "numbers.h" //Включает в код библиотеку
int main(){
std::cout << number; // 5
}
```
В консоли появится 5

---

## ```#define```
### define(с англ. Определить) - Создаёт константное(неизменяемое) выражение и определяет его значение. 
### Пример
```cpp {hl_lines=["4"]}
#include <iostream>
using namespace std;

#define N 23

int main()
{

    int x = N;

    cout << "Number: " << x; // Number: 23

    return 0;

}
```
### Более сложный пример:

```cpp {hl_lines=["3","5","7"]}
#include <iostream>

#define BEGIN {

#define END }

#define N 23

using namespace std;

int main()
BEGIN
    int x = N;
    cout << "Number: " << x;   // Number: 23
    return 0;
END
```
Здесь определены три идентификатора BEGIN, END, N. В итоге все вхождения последовательности символов "BEGIN" будут заменяться на открывающую фигурную скобку, а "END" - на закрывающую, а символ "N" на число 23.

Таким образом, после обработки препроцессора функция main приобретет следующий вид:
```cpp {hl_lines=["3"]}
int main()
{
    int x = 23;
    std::cout << "Number: " << x;
    return 0;
}
```

`#define` также может определять более сложные выражения. Например:

```cpp {hl_lines=["3","15"]}
#include <iostream>

#define ADD(a,b) (a+b)

using namespace std;

int main(void)

{

    int n1 = 10;

    int n2 = 5;

    cout << n1 << " + " << n2 << " = " << ADD(n1,n2) // 10 + 5 = 15

}
```

Особенно удобно использовать директиву #`define` для определения размеров массивов:
```cpp {hl_lines=["4"]}
#include <stdio.h>
using namespace std;

#define N 4

int main()

{

    int numbers[N] = {1, 2, 3, 4};

    for(int i=0; i<N; i++)

    {

        cout << numbers[i];

    }

    return 0;

}
```
### Для удаление идентификатора используется директива `#undef`: 
```cpp
#undef Индентификатор
```
### Например: 
```cpp
#include <iostream>
using namespace std;

#define STRING "Good morning \n"

int main()

{

    cout << STRING;

    #undef STRING

    #define STRING "Good afternoon \n"

    cout << STRING;

    #undef STRING

    #define STRING "Good evening \n"

    cout << STRING;

    return 0;

}
```


---



## ```#if```,```#else```,```#endif```,```#elif```(Условная Компиляция):
Директивы условной компиляции позволяют в зависимости от условий добавить добавить в файл определенный код.

Прежде всего это такие директивы как `#if/#else/#endif`, действие которых напоминает условную конструкцию if:
```c++ {hl_lines=["1","5"]}
#if условие

исходный_код

#endif //Окончание условия
```
Если условие возвращает ненулевое значение (то есть оно истинно), то в итоговый исходный файл вставляется исходный код, который расположен между директивами `#if` и `#endif`:
```cpp {hl_lines=["10","14-15"]}
#include <iostream>
using namespace std;

#define N 22

int main()

{

#if N==22

    cout << "n == 22";

#endif

    return 0;

}
```
Директива `#else` позволяет задать альтернативный код, который компилируется, если условие не верно:
```cpp {hl_lines=["10","14","18"]}
#include <iostream>
using namespace std;

#define N 22

int main()

{

#if N==22

    cout << "N=22";

#else

    cout << "N is undefined";

#endif

    return 0;

}
```
С помощью директивы `#elif` можно проверять дополнительные условия:
```cpp {hl_lines=["10","14","18-19","22"]}
#include <iostream>
using namespace std;

#define N 24

int main()

{

#if N==22

    cout << "N = 22";

#elif N==24

    cout << "N=24";

#else

    cout << "N is undefined"

#endif

    return 0;

}
```
## ```#pragma```
### `#pragma` — это директива, которая передает команды компилятору.
### Примеры использования:

**Отключение предупреждений (Visual Studio)**: В компиляторе Visual Studio можно отключать определенные предупреждения, используя `#pragma`:
```cpp
#pragma warning(disable : 4996)
```
в данном примере компилятор не будет выдавать предупреждение 4996, которое возникает при использовании устаревших функций.

**Запрет повторного запуска**:
Для заголовочный файлов(.h) не обходимо прописывать в начале `#pragma once` да бы не возникало исключений если в коде вы случайно указали дважды включение одной библиотеки, Например:
```cpp
#pragma once
Исходный код
```
Тем самым если в коде вы пропишете два `#include` с одной библиотекой она запуститься лишь раз не вызвав проблем с повторными переменными/функциями.



---

# Структуры
## Структуры - это пользовательские типы данных, которые позволяют объединять несколько переменных  разных типов под одним именем. Это полезно для создания логически связанных групп данных, таких как координаты точек, информация о студенте или данные о товарах.
### Для определения структуры применяется ключевое слово struct, а сам формат определения выглядит следующим образом:
```cpp
struct имя_структуры
{
    компоненты_структуры
};
```
`Имя_структуры` представляет произвольный идентификатор, к которому применяются те же правила, что и при наименовании переменных. После имени структуры в фигурных скобках помещаются компоненты структуры - переменные и функции.
### Например, определим простейшую структуру:
```cpp {hl_lines=["3","15"]}
#include <iostream>
using namespace std;
struct person
{
    unsigned age;
    string name;
};

int main()
{

    person tom;
    tom.name = "Tom";
    tom.age = 34;
    cout << "Name: " << tom.name << "\tAge: " << tom.age << endl; // Name: Tom  Age: 34

}
```
Здесь определена структура `person`, которая имеет две переменных: `name` (представляет тип string) и `age` (представляет тип unsigned).

## После определения структуры мы можем ее использовать. Для начала мы можем определить объект структуры - по сути обычную переменную, которая будет представлять выше созданный тип. Также после создания переменной структуры можно обращаться к ее элементам - получать их значения или, наоборот, присваивать им новые значения. Для обращения к элементам структуры используется операция "точка":
## `Имя_переменной_структуры.имя_элемента`

## Для инициализации Переменной со структурой:
## `person tom{ 34, "Tom" };`

### Вложенные структуры

В C++ структуры могут содержать другие структуры:
```cpp
struct Point {
	int x; // Координата по оси X 
	int y; // Координата по оси Y };
}

struct Rectangle {
    Point topLeft;      // Левая верхняя точка
    Point bottomRight;  // Правая нижняя точка
};
```
Здесь структура `Rectangle` использует структуру `Point` для описания своих углов.


### Передача структур в функции

Структуры можно передавать в функции и возвращать из них как любые другие типы данных. Однако передача по значению может быть затратной, особенно для больших структур, поэтому часто структуры передают по ссылке:
```cpp
void printPoint(const Point& p) {
    std::cout << "X: " << p.x << ", Y: " << p.y << std::endl;
}
```
### Основные отличия структуры от класса

Разница между классами и структурами минимальна:

1. **Спецификатор доступа**: В структуре все члены по умолчанию являются `public`, а в классе — `private`.
2. **Наследование и ООП**: Структуры могут поддерживать наследование и инкапсуляцию, как и классы.
