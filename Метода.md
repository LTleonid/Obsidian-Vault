Тема: Структуры, Директории Препроцессора


# Директивы Препроцессора
---
## Директивы Препроцессора  -  Это команды, которые выполняются до запуска основного кода. Препроцессор добавляет в компилятор нужные библиотеки, макросы или же помогает определить что-либо в компиляторе.
![86cb3fa2a7b0a0c425bc10c74ce3d5dd](https://github.com/user-attachments/assets/c4072e55-f188-408d-b0bb-7ebb7f26b478)



# Директивы

## ```#include ``` :

### Директив include(с англ. -  Включать/Содержать) - Позволяет добавить к коду какую либо библиотеку для дальнейшей работы с ней
### например ``` #include <iostream> ```
Включает в код стандартную библиотеку iostream в код, 

### Учтите - В треугольных кавычках <> записываются стандартные библиотеки которые установлены по умолчанию | В Двустрочные кавычки " ", Включаются твои библиотеки(Обязательно указывается файл с расширением .h - Header )
```cpp
#include <map> //Включает СТАНДРАТНУЮ библиотеку map
#include "YourBiblo.h" //Включает ВАШУ библиотеку YourBiblio.h
```

### Основные стандартные библиотеки:

1. **`<iostream>`** — для ввода и вывода данных (потоки `cin`, `cout`, `cerr`).).
2. **`<string>`** — для работы с объектами строк (`std::string`).
3. **`<algorithm>`** — для алгоритмов сортировки, поиска и работы с диапазонами (например, `std::sort`, `std::find`).
4. **`<cmath>`** - Для математических выражений (`std::abs`, `std::max`, `std::sqrt`) 

### Контейнеры STL:

1. **`std::vector`** — динамический массив. Автоматически расширяется при добавлении элементов.
2. **`std::deque`** — двусторонняя очередь. Быстрая вставка и удаление элементов как с начала, так и с конца.
3. **`std::list`** — двусвязный список. Эффективен для частых операций вставки и удаления в середине.
4. **`std::forward_list`** — односвязный список. Экономичнее по памяти, но менее функционален, чем `std::list`.
5. **`std::set`** — упорядоченное множество. Элементы хранятся в отсортированном порядке, каждый элемент уникален.
6. **`std::unordered_set`** — неупорядоченное множество. Использует хеш-таблицы для хранения элементов, обеспечивая быстрый доступ.
7. **`std::map`** — ассоциативный массив, где ключи отсортированы. Каждый ключ уникален и связан с определенным значением.
8. **`std::unordered_map`** — неупорядоченный ассоциативный массив. Быстрый доступ к элементам за счет хеширования ключей.
11. **`std::stack`** — контейнер, работающий по принципу "последним пришел — первым вышел" (LIFO).
12. **`std::queue`** — очередь, работающая по принципу "первым пришел — первым вышел" (FIFO).
13. **`std::priority_queue`** — очередь с приоритетом, в которой элементы извлекаются в порядке их приоритета.
14. **`std::array`** — статический массив фиксированного размера, определяемый во время компиляции.


### Как определить Заголовочный файл(Библиотеку):
Кроме стандартных заголовочных файлов мы можем подключать и свои файлы. Например, в той же папке, где находиться главный файл программы, определим еще два файл, который назовем numbers.h и numbers.cpp (файлы должны называться одинаков).

В файлах .h **объявляются** переменные, функции и классы.
```cpp {hl_lines=["1"]}
//numbers.h
int var1;
string var2;

struct struct1{
	int a;
	int b;
}
```
в файлах .cpp **реализуются** переменные функции и классы
```cpp {hl_lines=["1"]}
//numbers.cpp
#include <iostream>
using namespace std;
int var = 1;
string var = "123"
struct struct1{
	int a = 1;
	int b = 2;
}

```
В коде основного файла записывается только .h файл:
```cpp {hl_lines=["2"]}
#include <iostream>
#include "numbers.h"
```

---

## ```#define```
### define(с англ. Определить) - Создаёт константное(неизменяемое) выражение и определяет его значение. 
### Пример
```cpp {hl_lines=["4"]}
#include <iostream>
using namespace std;

#define N 23

int main()
{

    int x = N;

    cout << "Number: " << x; // Number: 23

    return 0;

}
```
### Более сложный пример:

```cpp {hl_lines=["3","5","7"]}
#include <iostream>

#define BEGIN {

#define END }

#define N 23

using namespace std;

int main()
BEGIN
    int x = N;
    cout << "Number: " << x;   // Number: 23
    return 0;
END
```
Здесь определены три идентификатора BEGIN, END, N. В итоге все вхождения последовательности символов "BEGIN" будут заменяться на открывающую фигурную скобку, а "END" - на закрывающую, а символ "N" на число 23.

Таким образом, после обработки препроцессора функция main приобретет следующий вид:
```cpp {hl_lines=["3"]}
int main()
{
    int x = 23;
    std::cout << "Number: " << x;
    return 0;
}
```

`#define` также может определять более сложные выражения. Например:

```cpp {hl_lines=["3","15"]}
#include <iostream>

#define ADD(a,b) (a+b)

using namespace std;

int main(void)

{

    int n1 = 10;

    int n2 = 5;

    cout << n1 << " + " << n2 << " = " << ADD(n1,n2) // 10 + 5 = 15

}
```
`#define ADD(a,b) (a+b)` - Называют ещё Макрос
Чем они отличаются от Функций?

|         | Различия                                                                                                                           |                                                                                                           |                      |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | -------------------- |
| Функция | выполняются самостоятельно и не зависят от места в коде, откуда были вызваны.                                                      | выполняют проверку типов: если функция ожидает на входе строку, а получает число, будет выброшена ошибка. |                      |
| Макрос  | можно условно назвать функцией обработки и замены программного кода: после сборки программы макросы заменяются макроопределениями. | просто заменяют аргумент, который им передан.                                                             | не подлежат отладке. |
**Преимущество макросов** перед функциями — производительность. Макрос быстрее, чем функция.

Особенно удобно использовать директиву #`define` для определения размеров массивов:
```cpp {hl_lines=["4"]}
#include <stdio.h>
using namespace std;

#define N 4

int main()

{

    int numbers[N] = {1, 2, 3, 4};

    for(int i=0; i<N; i++)

    {

        cout << numbers[i];

    }

    return 0;

}
```
### Для удаление идентификатора используется директива `#undef`: 
```cpp
#undef Индентификатор
```
### Например: 
```cpp
#include <iostream>
using namespace std;

#define STRING "Good morning \n"

int main()

{

    cout << STRING;

    #undef STRING

    #define STRING "Good afternoon \n"

    cout << STRING;

    #undef STRING

    #define STRING "Good evening \n"

    cout << STRING;

    return 0;

}
```


---



## ```#if```,```#else```,```#endif```,```#elif```(Условная Компиляция):
Директивы условной компиляции позволяют в зависимости от условий добавить добавить в файл определенный код.

Прежде всего это такие директивы как `#if/#else/#endif`, действие которых напоминает условную конструкцию if:
```c++ {hl_lines=["1","5"]}
#if условие

исходный_код

#endif //Окончание условия
```
Если условие возвращает ненулевое значение (то есть оно истинно), то в итоговый исходный файл вставляется исходный код, который расположен между директивами `#if` и `#endif`:
```cpp {hl_lines=["10","14"]}
#include <iostream>
using namespace std;

#define N 22

int main()

{

#if N==22

    cout << "n == 22";

#endif

    return 0;

}
```
Директива `#else` позволяет задать альтернативный код, который компилируется, если условие не верно:
```cpp {hl_lines=["10","14","18"]}
#include <iostream>
using namespace std;

#define N 22

int main()

{

#if N==22

    cout << "N=22";

#else

    cout << "N is undefined";

#endif

    return 0;

}
```
С помощью директивы `#elif` можно проверять дополнительные условия:
```cpp {hl_lines=["10","14","18-19","22"]}
#include <iostream>
using namespace std;

#define N 24

int main()

{

#if N==22

    cout << "N = 22";

#elif N==24

    cout << "N=24";

#else

    cout << "N is undefined"

#endif

    return 0;

}
```
## ```#pragma```
### `#pragma` — это директива, которая передает команды компилятору.
### Примеры использования:

**Отключение предупреждений (Visual Studio)**: В компиляторе Visual Studio можно отключать определенные предупреждения, используя `#pragma`:
```cpp
#pragma warning(disable : 4996)
```
в данном примере компилятор не будет выдавать предупреждение 4996, которое возникает при использовании устаревших функций.

**Запрет повторного запуска**:
Для заголовочный файлов(.h) не обходимо прописывать в начале `#pragma once` да бы не возникало исключений если в коде вы случайно указали дважды включение одной библиотеки, Например:
```cpp
#pragma once
Исходный код
```
Тем самым если в коде вы пропишете два `#include` с одной библиотекой она запуститься лишь раз не вызвав проблем с повторными переменными/функциями.



---

# Структуры
## Структуры - это пользовательские типы данных, которые позволяют объединять несколько переменных  разных типов под одним именем. Это полезно для создания логически связанных групп данных, таких как координаты точек, информация о студенте или данные о товарах.
### Для определения структуры применяется ключевое слово struct, а сам формат определения выглядит следующим образом:
```cpp
struct имя_структуры
{
    компоненты_структуры
};
```
`Имя_структуры` представляет произвольный идентификатор, к которому применяются те же правила, что и при наименовании переменных. После имени структуры в фигурных скобках помещаются компоненты структуры - переменные и функции.
### Например, определим простейшую структуру:
```cpp {hl_lines=["3","15"]}
#include <iostream>
using namespace std;
struct person
{
    unsigned age;
    string name;
};

int main()
{

    person tom;
    tom.name = "Tom";
    tom.age = 34;
    cout << "Name: " << tom.name << "\tAge: " << tom.age << endl; // Name: Tom  Age: 34

}
```
Здесь определена структура `person`, которая имеет две переменных: `name` (представляет тип string) и `age` (представляет тип unsigned).

## После определения структуры мы можем ее использовать. Для начала мы можем определить объект структуры - по сути обычную переменную, которая будет представлять выше созданный тип. Также после создания переменной структуры можно обращаться к ее элементам - получать их значения или, наоборот, присваивать им новые значения. Для обращения к элементам структуры используется операция "точка":
#### `Имя_переменной_структуры.имя_элемента`

### Для инициализации Переменной со структурой:
#### `person tom{ 34, "Tom" };`

### Вложенные структуры

В C++ структуры могут содержать другие структуры:
```cpp
struct Point {
	int x; // Координата по оси X 
	int y; // Координата по оси Y };
}

struct Rectangle {
    Point topLeft;      // Левая верхняя точка
    Point bottomRight;  // Правая нижняя точка
};
```
Здесь структура `Rectangle` использует структуру `Point` для описания своих углов.


### Передача структур в функции

Структуры можно передавать в функции и возвращать из них как любые другие типы данных. Однако передача по значению может быть затратной, особенно для больших структур, поэтому часто структуры передают по ссылке:
```cpp
void printPoint(const Point& p) {
    std::cout << "X: " << p.x << ", Y: " << p.y << std::endl;
}
```
### Основные отличия структуры от класса

Разница между классами и структурами минимальна:

1. **Спецификатор доступа**: В структуре все члены по умолчанию являются `public`, а в классе — `private`.
2. **Наследование и ООП**: Структуры могут поддерживать наследование и инкапсуляцию, как и классы.
